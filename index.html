<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ARTSIFY – drop → artsify → zip</title>
  <!-- Google Fonts: Workbench (console) & Atkinson Hyperlegible (timestamp) -->
  <link href="https://fonts.googleapis.com/css2?family=Workbench:wght@400..900&family=Atkinson+Hyperlegible:wght@700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0d0f12;
      --fg: #e6e6e6;
      --muted: #8a8f98;
      --accent: #40d16a;
      --danger: #ff6b6b;
      --console-font: 'Workbench', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      --stamp-font: 'Atkinson Hyperlegible', 'Atkinson Hyperlegible Next', system-ui, sans-serif;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
    }
    .app {
      height: 100%;
      width: 100%;
      position: relative;
    }

    /* DROPZONE */
    .dropzone {
      position: absolute;
      inset: 16px; /* slight inset so rounded corners are visible */
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 50%, #151922 0%, #0d0f12 65%);
      border: 4px dashed #303846;
      border-radius: 18px; /* slight rounding */
      padding: 24px; /* breathing room */
      box-sizing: border-box;
      transition: opacity .35s ease, transform .35s ease;
      z-index: 3;
    }
    .dropzone.hidden { opacity: 0; pointer-events: none; transform: scale(0.99); animation: none !important; }
    .dropzone p {
      font-family: var(--console-font);
      font-weight: 900; /* extrabold */
      font-variation-settings: 'wght' 900;
      letter-spacing: .12em;
      font-size: clamp(14px, 1.7vw, 18px); /* match console size */
      margin: 0;
      color: #dfe7ff;
      text-shadow: 0 2px 0 #000;
      user-select: none;
    }
    .dropzone.dragover { border-color: #4bff9b; box-shadow: 0 0 0 8px rgba(75,255,155,0.08) inset; }

    /* CONSOLE */
    .console {
      position: absolute; inset: 0; overflow: auto; padding: 28px 28px 80px;
      font-family: var(--console-font);
      background: repeating-linear-gradient(#0f131a 0 2px, transparent 2px 40px),
                  linear-gradient(180deg, #0a0d11, #0d1016);
      line-height: 1.55;
      display: none;
    }
    .console.visible { display: block; }
    .line { white-space: pre-wrap; word-break: break-word; font-size: clamp(14px, 1.7vw, 18px); }
    .muted { color: var(--muted); }
    .ok { color: var(--accent); font-weight: 700; }
    .skip { color: #93a1b3; }
    .err { color: var(--danger); }
    .actions { margin-top: 22px; }
    .link {
      color: #dfe7ff;
      text-decoration: none;
      font-weight: 900; /* extrabold */
      font-variation-settings: 'wght' 900;
      margin: 0; padding: 0;
      border-bottom: 2px solid transparent;
    }
    .link:hover { border-bottom-color: currentColor; }

    /* Hide the helper input but keep it accessible for click */
    #fileInput { position: absolute; inset: 0; opacity: 0; pointer-events: none; }

    /* ===== CRT-style subtle flicker ===== */
    @keyframes crt-flicker {
      0%   { opacity: 0.996; filter: brightness(1) contrast(1); }
      50%  { opacity: 0.990; filter: brightness(1.02) contrast(1.01); }
      100% { opacity: 0.996; filter: brightness(1) contrast(1); }
    }
    @keyframes crt-scan {
      0%   { background-position: 0 0; }
      100% { background-position: 0 8px; }
    }
    /* Apply gentle, fast-ish flicker to both states */
    .console, .dropzone { animation: crt-flicker 0.11s steps(2, end) infinite; }
    /* Very subtle noise/scan overlay for a tube-like feel */
    .app::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        repeating-linear-gradient(0deg,
          rgba(255,255,255,0.02) 0px,
          rgba(255,255,255,0.02) 1px,
          transparent 1px,
          transparent 2px);
      opacity: 0.06;
      mix-blend-mode: screen;
      animation: crt-scan 6s linear infinite;
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="dropzone" id="dropzone" tabindex="0" aria-label="Drop images, folders, or zips here">
      <p>DROP</p>
      <input id="fileInput" type="file" multiple webkitdirectory directory />
    </div>
    <div class="console" id="console" role="log" aria-live="polite"></div>
  </div>

  <!-- Dependencies: JSZip & EXIFR (for EXIF reading) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.umd.js"></script>

  <script>
  (function(){
    'use strict';

    // ===== DOM & STATE =====
    var $ = function(s){ return document.querySelector(s); };
    var dropzone = $('#dropzone');
    var logEl = $('#console');
    var TZ = 'Europe/Berlin';
    var DEBUG = true;

    var IMAGES_EXT = ['jpg','jpeg','png','webp','gif','bmp','tif','tiff','heic','heif'];
    var state = { queue: [], zip: new JSZip(), zipName: null, processedCount: 0, downloadUrl: null };

    // ===== LOGGING =====
    function println(html){ var div=document.createElement('div'); div.className='line'; div.innerHTML=html; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
    function dlog(msg){ if(!DEBUG) return; var s='[ARTSIFY] '+msg; try{ console.debug(s); }catch(e){} println("<span class='muted'>"+escapeHtml(s)+"</span>"); }

    // ===== UI =====
    function showConsole(){ logEl.classList.add('visible'); dropzone.classList.add('hidden'); }
    function showDrop(){ logEl.classList.remove('visible'); dropzone.classList.remove('hidden'); }
    function clearState(){ if(state.downloadUrl) URL.revokeObjectURL(state.downloadUrl); state.queue=[]; state.zip=new JSZip(); state.zipName=null; state.processedCount=0; state.downloadUrl=null; logEl.innerHTML=''; }

    // ===== UTILS =====
    function escapeHtml(s){ var map={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}; return String(s).replace(/[&<>"']/g, function(ch){ return map[ch] || ch; }); }
    function extOf(name){ name=name||''; var m=/(\.)([^.]+)$/.exec(name.toLowerCase()); return m?m[2]:''; }
    function isImageName(name){ return IMAGES_EXT.indexOf(extOf(name))>-1; }
    function mimeFromName(name){ var e=extOf(name); var map={jpg:'image/jpeg',jpeg:'image/jpeg',png:'image/png',webp:'image/webp',gif:'image/gif',bmp:'image/bmp',tif:'image/tiff',tiff:'image/tiff',heic:'image/heic',heif:'image/heif'}; return map[e]||'application/octet-stream'; }

    function fmtDateForStamp(d){ var m=['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC']; return m[d.getMonth()]+' '+String(d.getDate()).padStart(2,'0')+', '+d.getFullYear(); }
    function fmtDateFileYYYYMMDD(d){ var yyyy=d.getFullYear(); var mm=String(d.getMonth()+1).padStart(2,'0'); var dd=String(d.getDate()).padStart(2,'0'); return yyyy+'-'+mm+'-'+dd; }
    function fmtNowForZipName(){ var fmt=new Intl.DateTimeFormat('en-GB',{ timeZone:TZ, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' }); var parts={}; fmt.formatToParts(new Date()).forEach(function(p){ parts[p.type]=p.value; }); return parts.year+'-'+parts.month+'-'+parts.day+'-'+parts.hour+'-'+parts.minute; }

    // ===== INPUT EXPANSION =====
    function walkEntry(entry){ return new Promise(function(resolve){ if(entry.isFile){ entry.file(function(f){ resolve([f]); }); } else if(entry.isDirectory){ var dirReader=entry.createReader(); var files=[]; var read=function(){ dirReader.readEntries(function(entries){ if(!entries.length) return resolve(files); var i=0; (function next(){ if(i>=entries.length){ read(); return; } walkEntry(entries[i++]).then(function(arr){ files = files.concat(arr); next(); }); })(); }); }; read(); } else { resolve([]); } }); }

    async function gatherDroppedFiles(dt){
      // Deterministically collect from all available sources
      const out = [];

      // 1) Direct files list (most reliable across browsers)
      const byFiles = Array.from((dt && dt.files) ? dt.files : []);
      out.push(...byFiles);

      // 2) Items → getAsFile (plain files)
      const items = Array.from((dt && dt.items) ? dt.items : []);
      for (const it of items) {
        if (it.kind === 'file' && it.getAsFile) {
          const f = it.getAsFile(); if (f) out.push(f);
        }
      }

      // 3) Items → webkitGetAsEntry (folders in Chromium/Safari)
      const entryTasks = [];
      for (const it of items) {
        const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
        if (entry) entryTasks.push(walkEntry(entry));
      }
      if (entryTasks.length) {
        const nested = await Promise.all(entryTasks);
        nested.flat().forEach(f => out.push(f));
      }

      // De-dupe by name+size
      const seen = new Set();
      const dedup = out.filter(f => { const k = (f && f.name ? f.name : 'noname') + '|' + (f && f.size ? f.size : 0); if (seen.has(k)) return false; seen.add(k); return true; });
      dlog('gatherDroppedFiles → ' + dedup.length);
      return dedup;
    }

    // ===== ZIP EXPANSION & FILTER =====
    function expandZipsAndFilter(files){
      return new Promise(function(resolve){
        (async function(){
          var result=[];
          for (var i=0;i<files.length;i++){
            var f=files[i]; var nameLower=(f.name||'').toLowerCase();
            if (nameLower.endsWith('.zip') || f.type==='application/zip'){
              try{
                var zip = await JSZip.loadAsync(f);
                var entries = Object.values(zip.files);
                for (var j=0;j<entries.length;j++){
                  var ent = entries[j]; if (ent.dir) continue;
                  if (!isImageName(ent.name)) { println("<span class='err'>×<\/span> Skipped: "+escapeHtml(ent.name)+" <span class='muted'>(not an image)<\/span>"); continue; }
                  var blob = await ent.async('blob');
                  var f2 = new File([blob], ent.name.split('/').pop(), { type: mimeFromName(ent.name), lastModified: ent.date ? +ent.date : Date.now() });
                  result.push(f2);
                }
              } catch(err){ println("<span class='err'>× failed to read zip:</span> "+escapeHtml(f.name)+" – "+escapeHtml(String(err))); }
            } else if (isImageName(f.name)) {
              result.push(f);
            } else {
              println("<span class='err'>×<\/span> Skipped: "+escapeHtml(f.name)+" <span class='muted'>(not an image)<\/span>");
            }
          }
          resolve(result);
        })();
      });
    }

    // ===== DATES =====
    function getBestDate(file){
      return new Promise(async function(resolve){
        function normalizeUTCDate(d){ return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())); }
        function parseExifDate(raw){
          if (raw && raw instanceof Date && !isNaN(+raw)) return raw;
          if (typeof raw === 'string'){
            // EXIF-style: YYYY:MM:DD HH:MM:SS (take just the date part)
            var m = /(\d{4}):(\d{2}):(\d{2})/.exec(raw);
            if (m) return new Date(Date.UTC(+m[1], +m[2]-1, +m[3]));
            var t = Date.parse(raw);
            if (!isNaN(t)) return new Date(t);
          }
          return null;
        }
        // 1) Prefer EXIF date
        try {
          if (window.exifr && exifr.parse){
            var data = await exifr.parse(file, { tiff:true, exif:true });
            var raw = data && (data.DateTimeOriginal || data.CreateDate || data.ModifyDate);
            var exifDate = parseExifDate(raw);
            if (exifDate){
              return resolve({ date: normalizeUTCDate(exifDate), source: 'EXIF' });
            }
          }
        } catch(e) { /* ignore and fall back */ }
        // 2) Fallback: file timestamp (no filename guessing)
        var ts = new Date(file && file.lastModified ? file.lastModified : Date.now());
        return resolve({ date: normalizeUTCDate(ts), source: 'FILE' });
      });
    }

    // ===== DECODE & RENDER =====
    function loadAsImageBitmapOrMagick(file){
      return new Promise(async function(resolve, reject){
        var name = (file && file.name || '').toLowerCase();
        var ext = name.includes('.') ? name.split('.').pop() : '';

        async function sniffKind(f){
          try{
            const buf = await f.slice(0, 32).arrayBuffer();
            const u8 = new Uint8Array(buf);
            const head = String.fromCharCode.apply(null, u8);
            if ((u8[0]===0x49&&u8[1]===0x49&&u8[2]===0x2A&&u8[3]===0x00) || (u8[0]===0x4D&&u8[1]===0x4D&&u8[2]===0x00&&u8[3]===0x2A)) return 'tiff';
            if (u8[0]===0xFF && u8[1]===0xD8) return 'jpeg';
            if (u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4E && u8[3]===0x47) return 'png';
            if (head.startsWith('GIF8')) return 'gif';
            if (head.startsWith('RIFF') && head.substr(8,4)==='WEBP') return 'webp';
            if (head.substr(4,4)==='ftyp'){
              const brand = head.substr(8,4);
              if (brand==='heic' || brand==='heif' || brand==='mif1' || brand==='heix' || brand==='hevc') return 'heic';
            }
          }catch(e){}
          return '';
        }

        // 1) createImageBitmap (fast path)
        try{ var img1 = await createImageBitmap(file);  return resolve({ image: img1, type: file.type || mimeFromName(file.name) }); }catch(e){ dlog('decode: createImageBitmap failed'); }
        // 2) HTMLImageElement fallback
        try{
          var url = URL.createObjectURL(file);
          var img2 = new Image();
          img2.onload = function(){ URL.revokeObjectURL(url); dlog('decode: HTMLImageElement'); resolve({ image: img2, type: file.type || mimeFromName(file.name) }); };
          img2.onerror = function(){ URL.revokeObjectURL(url); (async()=>{ try { await afterHtmlImgFail(); } catch(e){ reject(e); } })(); };
          img2.src = url;
          return; // wait for onload/onerror
        }catch(e){ /* fall through */ }

        async function afterHtmlImgFail(){
          const kind = await sniffKind(file);
          dlog('decode: sniff kind='+kind+' ext='+ext+' mime='+(file.type||''));
          // HEIC/HEIF via heic2any
          if (((ext==='heic'||ext==='heif') || kind==='heic') && window.heic2any) {
            try {
              dlog('decode: heic2any fallback');
              var outBlob = await window.heic2any({ blob: file, toType: 'image/jpeg', quality: 0.92 });
              var img3 = await createImageBitmap(outBlob);
              resolve({ image: img3, type: 'image/jpeg' });
              return;
            } catch(e) { dlog('heic2any failed: '+String(e)); }
          }
          // TIFF via UTIF
          if (((ext==='tif'||ext==='tiff') || kind==='tiff') && window.UTIF) {
            try {
              dlog('decode: UTIF fallback');
              var buf = await file.arrayBuffer();
              var ifds = UTIF.decode(buf);
              if (ifds && ifds.length){
                UTIF.decodeImage(buf, ifds[0]);
                var rgba = UTIF.toRGBA8(ifds[0]);
                var w = ifds[0].width || ifds[0].t256 || 0;
                var h = ifds[0].height || ifds[0].t257 || 0;
                if (w>0 && h>0){
                  var cvs = document.createElement('canvas'); cvs.width=w; cvs.height=h; var ctx=cvs.getContext('2d');
                  var imgData = ctx.createImageData(w,h); imgData.data.set(rgba); ctx.putImageData(imgData,0,0);
                  var bmp = await createImageBitmap(cvs);
                  resolve({ image: bmp, type: 'image/png' });
                  return;
                }
              }
            } catch(e) { dlog('UTIF failed: '+String(e)); }
          }
          // Last resort
          reject(new Error('Unsupported or corrupt image; tried browser, HEIC, TIFF decoders.'));
        }
      });
    }

    function processOne(item){
      return new Promise(async function(resolve){
        var file=item.file, originName=item.originName;
        var best = await getBestDate(file); var date=best.date, source=best.source;
        var stamp = fmtDateForStamp(date); var datePrefix = fmtDateFileYYYYMMDD(date);
        var decoded = await loadAsImageBitmapOrMagick(file); var image=decoded.image, type=decoded.type;
        var w=image.width, h=image.height; var shorter=Math.min(w,h);
        var border=Math.max(1, Math.round(0.02*shorter)); var textPx=Math.max(8, Math.round(0.5*border));
        var canvas=document.createElement('canvas'); canvas.width=w+border*2; canvas.height=h+border*2; var ctx=canvas.getContext('2d');
        ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(image, border, border, w, h);
        ctx.fillStyle='#000000'; ctx.font='700 '+textPx+'px '+"Atkinson Hyperlegible"+', '+"Atkinson Hyperlegible Next"+', system-ui, sans-serif'; ctx.textAlign='right'; ctx.textBaseline='middle';
        var xRight=border+w; var yCenterBottomBorder=canvas.height - border/2; ctx.fillText(stamp, xRight, yCenterBottomBorder);
        var targetType=/jpe?g/i.test(originName)?'image/jpeg':(type||'image/png');
        canvas.toBlob(function(blob){
          var newName=datePrefix+'-'+originName; state.zip.file(newName, blob); state.processedCount++; println("<span class='ok'>✓</span> "+escapeHtml(newName)+"    <span class='muted'>"+escapeHtml(stamp)+" • "+source+"</span>"); resolve();
        }, targetType==='image/jpeg'?'image/jpeg':'image/png', 0.92);
      });
    }

    function handleFiles(files){
      return new Promise(async function(resolve){
        clearState(); showConsole();
        var expanded = await expandZipsAndFilter(files); println(expanded.length+" images found");
        state.queue = expanded.map(function(f){ return { file:f, originName:f.name }; });
        for (var i=0;i<state.queue.length;i++){
          var item = state.queue[i];
          try { await processOne(item); } catch(err){ println("<span class='err'>×</span> "+escapeHtml(item.originName)+" <span class='muted'>"+escapeHtml(String(err))+"</span>"); }
        }
        var stamp=fmtNowForZipName(); var zipName='artsified-'+stamp+'.zip';
        var blob=await state.zip.generateAsync({ type:'blob', compression:'DEFLATE', compressionOptions:{ level:6 } });
        var url=URL.createObjectURL(blob); state.downloadUrl=url; state.zipName=zipName;
        addDownloadReset(url, zipName);
        resolve();
      });
    }

    function addDownloadReset(url, zipName){
      var div=document.createElement('div'); div.className='line actions';
      var aDL=document.createElement('a'); aDL.className='link'; aDL.textContent='DOWNLOAD'; aDL.href=url; aDL.download=zipName;
      var aRS=document.createElement('a'); aRS.className='link'; aRS.textContent='RESET'; aRS.href='#'; aRS.addEventListener('click', function(e){ e.preventDefault(); resetAll(); });
      div.appendChild(aDL); div.appendChild(document.createTextNode('   |   ')); div.appendChild(aRS); /* hard spaces */
      logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
    }

    function addResetAction(){
      var div=document.createElement('div'); div.className='line actions';
      var aRS=document.createElement('a'); aRS.className='link'; aRS.textContent='RESET'; aRS.href='#'; aRS.addEventListener('click', function(e){ e.preventDefault(); resetAll(); });
      div.appendChild(aRS);
      logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
    }

    function resetAll(){ clearState(); showDrop(); }

    // ===== DND + PICKER =====
    function isDropzoneVisible(){ return !dropzone.classList.contains('hidden'); }

    // Prevent navigation
    window.addEventListener('dragover', function(e){ e.preventDefault(); }, false);
    window.addEventListener('drop', async function(e){
      e.preventDefault(); e.stopPropagation();
      if(!isDropzoneVisible()) return; // only handle when dropzone is shown
      dlog('window drop');
      var dt = e.dataTransfer || {};
      // Prefer direct files on drop (most reliable)
      var direct = Array.prototype.slice.call((dt.files||[]));
      var files = direct;
      if (!files.length && dt.items && dt.items.length){
        // Fallback: items->getAsFile
        files = Array.prototype.slice.call(dt.items).map(function(it){ return it.getAsFile ? it.getAsFile() : null; }).filter(Boolean);
      }
      if (!files.length){ files = await gatherDroppedFiles(dt); }
      dlog('window drop collected files='+files.length);
      if(files.length){ await handleFiles(files); }
      else { clearState(); showConsole(); println('0 images found'); addResetAction(); }
    }, false);

    // Dropzone visuals + drop handling
    dropzone.addEventListener('dragenter', function(e){ e.preventDefault(); dropzone.classList.add('dragover'); dlog('dropzone dragenter'); }, false);
    dropzone.addEventListener('dragover', function(e){ e.preventDefault(); }, false);
    dropzone.addEventListener('dragleave', function(e){ e.preventDefault(); dropzone.classList.remove('dragover'); dlog('dropzone dragleave'); }, false);
    dropzone.addEventListener('drop', async function(e){
      e.preventDefault(); e.stopPropagation();
      dropzone.classList.remove('dragover'); dlog('dropzone drop');
      var dt = e.dataTransfer || {};
      var direct = Array.prototype.slice.call((dt.files||[]));
      var files = direct;
      if (!files.length && dt.items && dt.items.length){
        files = Array.prototype.slice.call(dt.items).map(function(it){ return it.getAsFile ? it.getAsFile() : null; }).filter(Boolean);
      }
      if (!files.length){ files = await gatherDroppedFiles(dt); }
      dlog('dropzone drop collected files='+files.length);
      if(files.length){ await handleFiles(files); }
      else { clearState(); showConsole(); println('0 images found'); addResetAction(); }
    }, false);

    // Manual picker
    dropzone.addEventListener('click', function(){ dlog('open picker'); var input=document.createElement('input'); input.type='file'; input.multiple=true; input.webkitdirectory=true; input.setAttribute('directory',''); input.accept='.jpg,.jpeg,.png,.webp,.gif,.bmp,.tif,.tiff,.heic,.heif,.zip'; input.style.position='fixed'; input.style.left='-9999px'; document.body.appendChild(input); input.addEventListener('change', async function(ev){ var files=Array.prototype.slice.call(ev.target.files||[]); dlog('picker files='+files.length); if(files.length) await handleFiles(files); input.remove(); }, {once:true}); input.click(); }, false);

  })();
</script>
  <!-- Add HEIC/HEIF decoder fallback -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <!-- Add TIFF decoder fallback (UTIF) -->
  <script src="https://cdn.jsdelivr.net/npm/utif@3.0.0/UTIF.min.js"></script>
</body>
</html>
