<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ARTSIFY – drop → artsify → zip</title>
  <!-- Google Fonts: Workbench (console) & Atkinson Hyperlegible (timestamp) -->
  <link href="https://fonts.googleapis.com/css2?family=Workbench:wght@400..900&family=Atkinson+Hyperlegible:wght@700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0d0f12;
      --fg: #e6e6e6;
      --muted: #8a8f98;
      --accent: #40d16a;
      --danger: #ff6b6b;
      --console-font: 'Workbench', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      --stamp-font: 'Atkinson Hyperlegible', 'Atkinson Hyperlegible Next', system-ui, sans-serif;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
    }
    .app { height: 100%; width: 100%; position: relative; }

    /* DROPZONE */
    .dropzone {
      position: absolute;
      inset: 16px;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 50%, #151922 0%, #0d0f12 65%);
      border: 4px dashed #303846;
      border-radius: 18px;
      padding: 24px;
      box-sizing: border-box;
      transition: opacity .35s ease, transform .35s ease;
      z-index: 3;
    }
    .dropzone.hidden { opacity: 0; pointer-events: none; transform: scale(0.99); animation: none !important; }
    .dropzone p {
      font-family: var(--console-font);
      font-weight: 900;
      font-variation-settings: 'wght' 900;
      letter-spacing: .12em;
      font-size: clamp(14px, 1.7vw, 18px);
      margin: 0;
      color: #dfe7ff;
      text-shadow: 0 2px 0 #000;
      user-select: none;
    }
    .dropzone.dragover { border-color: #4bff9b; box-shadow: 0 0 0 8px rgba(75,255,155,0.08) inset; }

    /* CONSOLE */
    .console {
      position: absolute; inset: 0; overflow: auto; padding: 28px 28px 80px;
      font-family: var(--console-font);
      background: repeating-linear-gradient(#0f131a 0 2px, transparent 2px 40px),
                  linear-gradient(180deg, #0a0d11, #0d1016);
      line-height: 1.55;
      display: none;
    }
    .console.visible { display: block; }
    .line { white-space: pre-wrap; word-break: break-word; font-size: clamp(14px, 1.7vw, 18px); }
    .muted { color: var(--muted); }
    .ok { color: var(--accent); font-weight: 700; }
    .skip { color: #93a1b3; }
    .err { color: var(--danger); }
    .actions { margin-top: 22px; }
    .link {
      color: #dfe7ff;
      text-decoration: none;
      font-weight: 900;
      font-variation-settings: 'wght' 900;
      margin: 0; padding: 0;
      border-bottom: 2px solid transparent;
    }
    .link:hover { border-bottom-color: currentColor; }

    /* ===== CRT-style subtle flicker ===== */
    @keyframes crt-flicker {
      0%   { opacity: 0.996; filter: brightness(1) contrast(1); }
      50%  { opacity: 0.990; filter: brightness(1.02) contrast(1.01); }
      100% { opacity: 0.996; filter: brightness(1) contrast(1); }
    }
    @keyframes crt-scan {
      0%   { background-position: 0 0; }
      100% { background-position: 0 8px; }
    }
    .console, .dropzone { animation: crt-flicker 0.11s steps(2, end) infinite; }
    .app::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        repeating-linear-gradient(0deg,
          rgba(255,255,255,0.02) 0px,
          rgba(255,255,255,0.02) 1px,
          transparent 1px,
          transparent 2px);
      opacity: 0.06;
      mix-blend-mode: screen;
      animation: crt-scan 6s linear infinite;
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="dropzone" id="dropzone" tabindex="0" aria-label="Drop images, folders, or zips here">
      <p>DROP</p>
      <!-- removed unused hidden input -->
    </div>
    <div class="console" id="console" role="log" aria-live="polite"></div>
  </div>

  <!-- Load fallbacks FIRST to avoid race conditions -->
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/utif@3.0.0/UTIF.min.js"></script>

  <!-- Dependencies: JSZip & EXIFR (for EXIF reading) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.umd.js"></script>

  <script>
  (function(){
    'use strict';

    // ===== DOM & STATE =====
    var $ = function(s){ return document.querySelector(s); };
    var dropzone = $('#dropzone');
    var logEl = $('#console');
    var DEBUG = true;

    var IMAGES_EXT = ['jpg','jpeg','png','webp','gif','bmp','tif','tiff','heic','heif'];
    var state = { queue: [], zip: new JSZip(), zipName: null, processedCount: 0, downloadUrl: null };

    // ===== LOGGING =====
    function println(html){ var div=document.createElement('div'); div.className='line'; div.innerHTML=html; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
    function dlog(msg){ if(!DEBUG) return; var s='[ARTSIFY] '+msg; try{ console.debug(s); }catch(e){} println("<span class='muted'>"+escapeHtml(s)+"</span>"); }

    // ===== UI =====
    function showConsole(){ logEl.classList.add('visible'); dropzone.classList.add('hidden'); }
    function showDrop(){ logEl.classList.remove('visible'); dropzone.classList.remove('hidden'); }
    function clearState(){ if(state.downloadUrl) URL.revokeObjectURL(state.downloadUrl); state.queue=[]; state.zip=new JSZip(); state.zipName=null; state.processedCount=0; state.downloadUrl=null; logEl.innerHTML=''; }

    // ===== UTILS =====
    function escapeHtml(s){ var map={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}; return String(s).replace(/[&<>"']/g, function(ch){ return map[ch] || ch; }); }
    function extOf(name){ name=name||''; var m=/(\.)([^.]+)$/.exec(name.toLowerCase()); return m?m[2]:''; }
    function isImageName(name){ return IMAGES_EXT.indexOf(extOf(name))>-1; }
    function mimeFromName(name){ var e=extOf(name); var map={jpg:'image/jpeg',jpeg:'image/jpeg',png:'image/png',webp:'image/webp',gif:'image/gif',bmp:'image/bmp',tif:'image/tiff',tiff:'image/tiff',heic:'image/heic',heif:'image/heif'}; return map[e]||'application/octet-stream'; }

    // LOCAL time everywhere
    function fmtDateForStamp(d){
      var m=['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
      return m[d.getMonth()]+' '+String(d.getDate()).padStart(2,'0')+', '+d.getFullYear();
    }
    function fmtDateFileYYYYMMDD(d){
      var yyyy=d.getFullYear();
      var mm=String(d.getMonth()+1).padStart(2,'0');
      var dd=String(d.getDate()).padStart(2,'0');
      return yyyy+'-'+mm+'-'+dd;
    }
    function fmtNowForZipName(){
      var now=new Date();
      var yyyy=now.getFullYear();
      var mm=String(now.getMonth()+1).padStart(2,'0');
      var dd=String(now.getDate()).padStart(2,'0');
      var hh=String(now.getHours()).padStart(2,'0');
      var mi=String(now.getMinutes()).padStart(2,'0');
      return yyyy+'-'+mm+'-'+dd+'-'+hh+'-'+mi;
    }
    function toLocalDay(d){ return new Date(d.getFullYear(), d.getMonth(), d.getDate()); }

    // ===== INPUT EXPANSION =====
    function walkEntry(entry){ return new Promise(function(resolve){ if(entry.isFile){ entry.file(function(f){ resolve([f]); }); } else if(entry.isDirectory){ var dirReader=entry.createReader(); var files=[]; var read=function(){ dirReader.readEntries(function(entries){ if(!entries.length) return resolve(files); var i=0; (function next(){ if(i>=entries.length){ read(); return; } walkEntry(entries[i++]).then(function(arr){ files = files.concat(arr); next(); }); })(); }); }; read(); } else { resolve([]); } }); }

    async function gatherDroppedFiles(dt){
      const out = [];
      const byFiles = Array.from((dt && dt.files) ? dt.files : []);
      out.push(...byFiles);
      const items = Array.from((dt && dt.items) ? dt.items : []);
      for (const it of items) { if (it.kind === 'file' && it.getAsFile) { const f = it.getAsFile(); if (f) out.push(f); } }
      const entryTasks = [];
      for (const it of items) { const entry = it.webkitGetAsEntry && it.webkitGetAsEntry(); if (entry) entryTasks.push(walkEntry(entry)); }
      if (entryTasks.length) { const nested = await Promise.all(entryTasks); nested.flat().forEach(f => out.push(f)); }
      const seen = new Set();
      const dedup = out.filter(f => { const k = (f && f.name ? f.name : 'noname') + '|' + (f && f.size ? f.size : 0) + '|' + (f && f.lastModified ? f.lastModified : 0); if (seen.has(k)) return false; seen.add(k); return true; });
      dlog('gatherDroppedFiles → ' + dedup.length);
      return dedup;
    }

    // ===== ZIP EXPANSION & FILTER =====
    function expandZipsAndFilter(files){
      return new Promise(function(resolve){
        (async function(){
          var result=[];
          for (var i=0;i<files.length;i++){
            var f=files[i]; var nameLower=(f.name||'').toLowerCase();
            if (nameLower.endsWith('.zip') || f.type==='application/zip'){
              try{
                var zip = await JSZip.loadAsync(f);
                var entries = Object.values(zip.files);
                for (var j=0;j<entries.length;j++){
                  var ent = entries[j]; if (ent.dir) continue;
                  if (!isImageName(ent.name)) { println("<span class='err'>×<\/span> Skipped: "+escapeHtml(ent.name)+" <span class='muted'>(not an image)<\/span>"); continue; }
                  var blob = await ent.async('blob');
                  var f2 = new File([blob], ent.name.split('/').pop(), { type: mimeFromName(ent.name), lastModified: ent.date ? +ent.date : Date.now() });
                  result.push(f2);
                }
              } catch(err){ println("<span class='err'>× failed to read zip:</span> "+escapeHtml(f.name)+" – "+escapeHtml(String(err))); }
            } else if (isImageName(f.name)) {
              result.push(f);
            } else {
              println("<span class='err'>×<\/span> Skipped: "+escapeHtml(f.name)+" <span class='muted'>(not an image)<\/span>");
            }
          }
          resolve(result);
        })();
      });
    }

    // ===== DATES (local) + EXIF ORIENTATION =====
    function getBestDateAndExif(file){
      return new Promise(async function(resolve){
        function parseExifLocalDay(raw){
          if (raw && raw instanceof Date && !isNaN(+raw)) return toLocalDay(raw);
          if (typeof raw === 'string'){
            var m = /(\d{4}):(\d{2}):(\d{2})/.exec(raw);
            if (m) return new Date(+m[1], +m[2]-1, +m[3]); // local midnight
            var t = Date.parse(raw);
            if (!isNaN(t)) { var d=new Date(t); return toLocalDay(d); }
          }
          return null;
        }
        var orientation = 1;

        try {
          if (window.exifr && exifr.parse){
            var data = await exifr.parse(file, { tiff:true, exif:true });
            orientation = (data && data.Orientation) ? data.Orientation : 1;
            var raw = data && (data.DateTimeOriginal || data.CreateDate || data.ModifyDate);
            var exifDate = parseExifLocalDay(raw);
            if (exifDate){
              return resolve({ date: exifDate, source: 'EXIF', orientation: orientation });
            }
          }
        } catch(e) { /* fall through */ }

        var ts = new Date(file && file.lastModified ? file.lastModified : Date.now());
        return resolve({ date: toLocalDay(ts), source: 'FILE', orientation: orientation });
      });
    }

    // ===== DECODE =====
    function loadAsImageBitmapOrMagick(file){
      return new Promise(async function(resolve, reject){
        var name = (file && file.name || '').toLowerCase();
        var ext = name.includes('.') ? name.split('.').pop() : '';

        async function sniffKind(f){
          try{
            const buf = await f.slice(0, 32).arrayBuffer();
            const u8 = new Uint8Array(buf);
            const head = String.fromCharCode.apply(null, u8);
            if ((u8[0]===0x49&&u8[1]===0x49&&u8[2]===0x2A&&u8[3]===0x00) || (u8[0]===0x4D&&u8[1]===0x4D&&u8[2]===0x00&&u8[3]===0x2A)) return 'tiff';
            if (u8[0]===0xFF && u8[1]===0xD8) return 'jpeg';
            if (u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4E && u8[3]===0x47) return 'png';
            if (head.startsWith('GIF8')) return 'gif';
            if (head.startsWith('RIFF') && head.substr(8,4)==='WEBP') return 'webp';
            if (head.substr(4,4)==='ftyp'){
              const brand = head.substr(8,4);
              if (brand==='heic' || brand==='heif' || brand==='mif1' || brand==='heix' || brand==='hevc') return 'heic';
            }
          }catch(e){}
          return '';
        }

        try{ var img1 = await createImageBitmap(file);  return resolve({ image: img1, type: file.type || mimeFromName(file.name) }); }catch(e){ dlog('decode: createImageBitmap failed'); }
        try{
          var url = URL.createObjectURL(file);
          var img2 = new Image();
          img2.onload = function(){ URL.revokeObjectURL(url); dlog('decode: HTMLImageElement'); resolve({ image: img2, type: file.type || mimeFromName(file.name) }); };
          img2.onerror = function(){ URL.revokeObjectURL(url); (async()=>{ try { await afterHtmlImgFail(); } catch(e){ reject(e); } })(); };
          img2.src = url;
          return;
        }catch(e){ /* fall through */ }

        async function afterHtmlImgFail(){
          const kind = await sniffKind(file);
          dlog('decode: sniff kind='+kind+' ext='+ext+' mime='+(file.type||''));
          if (((ext==='heic'||ext==='heif') || kind==='heic') && window.heic2any) {
            try {
              dlog('decode: heic2any fallback');
              var outBlob = await window.heic2any({ blob: file, toType: 'image/jpeg', quality: 0.92 });
              var img3 = await createImageBitmap(outBlob);
              resolve({ image: img3, type: 'image/jpeg' });
              return;
            } catch(e) { dlog('heic2any failed: '+String(e)); }
          }
          if (((ext==='tif'||ext==='tiff') || kind==='tiff') && window.UTIF) {
            try {
              dlog('decode: UTIF fallback');
              var buf = await file.arrayBuffer();
              var ifds = UTIF.decode(buf);
              if (ifds && ifds.length){
                UTIF.decodeImage(buf, ifds[0]);
                var rgba = UTIF.toRGBA8(ifds[0]);
                var w = ifds[0].width || ifds[0].t256 || 0;
                var h = ifds[0].height || ifds[0].t257 || 0;
                if (w>0 && h>0){
                  var cvs = document.createElement('canvas'); cvs.width=w; cvs.height=h; var ctx=cvs.getContext('2d');
                  var imgData = ctx.createImageData(w,h); imgData.data.set(rgba); ctx.putImageData(imgData,0,0);
                  var bmp = await createImageBitmap(cvs);
                  resolve({ image: bmp, type: 'image/png' });
                  return;
                }
              }
            } catch(e) { dlog('UTIF failed: '+String(e)); }
          }
          reject(new Error('Unsupported or corrupt image; tried browser, HEIC, TIFF decoders.'));
        }
      });
    }

    // ===== EXIF ORIENTATION → canvas transform =====
    function applyOrientationTransform(ctx, orientation, w, h, ow, oh){
      // ctx is already translated to top-left of content area (border, border)
      switch (orientation) {
        case 2: // mirror horizontal
          ctx.translate(ow, 0); ctx.scale(-1, 1); break;
        case 3: // rotate 180
          ctx.translate(ow, oh); ctx.rotate(Math.PI); break;
        case 4: // mirror vertical
          ctx.translate(0, oh); ctx.scale(1, -1); break;
        case 5: // mirror horizontal + rotate 270 CW (transpose)
          ctx.rotate(0.5 * Math.PI);
          ctx.scale(1, -1);
          break;
        case 6: // rotate 90 CW
          ctx.rotate(0.5 * Math.PI);
          ctx.translate(0, -oh);
          break;
        case 7: // mirror horizontal + rotate 90 CW (transverse)
          ctx.rotate(0.5 * Math.PI);
          ctx.translate(ow, -oh);
          ctx.scale(-1, 1);
          break;
        case 8: // rotate 90 CCW
          ctx.rotate(-0.5 * Math.PI);
          ctx.translate(-ow, 0);
          break;
        default: /* 1: no transform */ break;
      }
    }

    // Orientation label for logging (hide "Horizontal (normal)")
    function orientationLabel(orientation){
      switch (orientation) {
        case 2: return 'ORI:Mirrored horizontal';
        case 3: return 'ORI:Rotated 180°';
        case 4: return 'ORI:Mirrored vertical';
        case 5: return 'ORI:Mirrored horizontal + Rotated 270°';
        case 6: return 'ORI:Rotated 90° CW';
        case 7: return 'ORI:Mirrored horizontal + Rotated 90°';
        case 8: return 'ORI:Rotated 90° CCW';
        default: return ''; // 1 -> hide
      }
    }

    function processOne(item){
      return new Promise(async function(resolve){
        var file=item.file, originName=item.originName;

        // date + exif orientation (local time)
        var best = await getBestDateAndExif(file);
        var date=best.date, source=best.source, orientation=best.orientation;

        var stamp = fmtDateForStamp(date);
        var datePrefix = fmtDateFileYYYYMMDD(date);

        var decoded = await loadAsImageBitmapOrMagick(file);
        var image=decoded.image, type=decoded.type;

        var w=image.width, h=image.height;
        var swap = (orientation>=5 && orientation<=8);
        var ow = swap ? h : w; // oriented width
        var oh = swap ? w : h; // oriented height

        var shorter=Math.min(ow,oh);
        var border=Math.max(1, Math.round(0.02*shorter));
        var textPx=Math.max(8, Math.round(0.5*border));

        // size guard (optional, prevents giant crashes)
        if (ow*oh > 50_000_000 || Math.max(ow, oh) > 16384) {
          println("<span class='skip'>↷</span> "+escapeHtml(originName)+" <span class='muted'>(too large; skipped)</span>");
          return resolve();
        }

        var canvas=document.createElement('canvas');
        canvas.width=ow+border*2; canvas.height=oh+border*2;
        var ctx=canvas.getContext('2d');

        // white border background
        ctx.fillStyle='#ffffff';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // draw oriented image inside border
        ctx.save();
        ctx.translate(border, border);
        applyOrientationTransform(ctx, orientation, w, h, ow, oh);
        ctx.drawImage(image, 0, 0, w, h);
        ctx.restore();

        // stamp text (unrotated; bottom-right on the outer border)
        ctx.fillStyle='#000000';
        ctx.font='700 '+textPx+'px '+"Atkinson Hyperlegible"+', '+"Atkinson Hyperlegible Next"+', system-ui, sans-serif';
        ctx.textAlign='right'; ctx.textBaseline='middle';
        var xRight=canvas.width - border; var yCenterBottomBorder=canvas.height - border/2;
        ctx.fillText(stamp, xRight, yCenterBottomBorder);

        var targetType=/jpe?g/i.test(originName)?'image/jpeg':(type||'image/png');
        canvas.toBlob(function(blob){
          var newName=datePrefix+'-'+originName;
          state.zip.file(newName, blob);
          state.processedCount++;
          const oriNote = orientationLabel(orientation);
          println("<span class='ok'>✓</span> "+escapeHtml(newName)+"    <span class='muted'>"+escapeHtml(stamp)+" • "+source+(oriNote ? " • "+oriNote : "")+"</span>");
          resolve();
        }, targetType==='image/jpeg'?'image/jpeg':'image/png', 0.92);
      });
    }

    function handleFiles(files){
      return new Promise(async function(resolve){
        clearState(); showConsole();
        var expanded = await expandZipsAndFilter(files); println(expanded.length+" images found");
        state.queue = expanded.map(function(f){ return { file:f, originName:f.name }; });
        for (var i=0;i<state.queue.length;i++){
          var item = state.queue[i];
          try { await processOne(item); } catch(err){ println("<span class='err'>×</span> "+escapeHtml(item.originName)+" <span class='muted'>"+escapeHtml(String(err))+"</span>"); }
        }
        var stamp=fmtNowForZipName(); var zipName='artsified-'+stamp+'.zip';
        var blob=await state.zip.generateAsync({ type:'blob', compression:'DEFLATE', compressionOptions:{ level:6 } });
        var url=URL.createObjectURL(blob); state.downloadUrl=url; state.zipName=zipName;
        addDownloadReset(url, zipName);
        resolve();
      });
    }

    function addDownloadReset(url, zipName){
      var div=document.createElement('div'); div.className='line actions';
      var aDL=document.createElement('a'); aDL.className='link'; aDL.textContent='DOWNLOAD'; aDL.href=url; aDL.download=zipName;
      var aRS=document.createElement('a'); aRS.className='link'; aRS.textContent='RESET'; aRS.href='#'; aRS.addEventListener('click', function(e){ e.preventDefault(); resetAll(); });
      div.appendChild(aDL); div.appendChild(document.createTextNode('   |   ')); div.appendChild(aRS);
      logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
    }

    function addResetAction(){
      var div=document.createElement('div'); div.className='line actions';
      var aRS=document.createElement('a'); aRS.className='link'; aRS.textContent='RESET'; aRS.href='#'; aRS.addEventListener('click', function(e){ e.preventDefault(); resetAll(); });
      div.appendChild(aRS);
      logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
    }

    function resetAll(){ clearState(); showDrop(); }

    // ===== DND + PICKER =====
    function isDropzoneVisible(){ return !dropzone.classList.contains('hidden'); }

    window.addEventListener('dragover', function(e){ e.preventDefault(); }, false);
    window.addEventListener('drop', async function(e){
      e.preventDefault(); e.stopPropagation();
      if(!isDropzoneVisible()) return;
      dlog('window drop');
      var dt = e.dataTransfer || {};
      var direct = Array.prototype.slice.call((dt.files||[]));
      var files = direct;
      if (!files.length && dt.items && dt.items.length){
        files = Array.prototype.slice.call(dt.items).map(function(it){ return it.getAsFile ? it.getAsFile() : null; }).filter(Boolean);
      }
      if (!files.length){ files = await gatherDroppedFiles(dt); }
      dlog('window drop collected files='+files.length);
      if(files.length){ await handleFiles(files); }
      else { clearState(); showConsole(); println('0 images found'); addResetAction(); }
    }, false);

    dropzone.addEventListener('dragenter', function(e){ e.preventDefault(); dropzone.classList.add('dragover'); dlog('dropzone dragenter'); }, false);
    dropzone.addEventListener('dragover', function(e){ e.preventDefault(); }, false);
    dropzone.addEventListener('dragleave', function(e){ e.preventDefault(); dropzone.classList.remove('dragover'); dlog('dropzone dragleave'); }, false);
    dropzone.addEventListener('drop', async function(e){
      e.preventDefault(); e.stopPropagation();
      dropzone.classList.remove('dragover'); dlog('dropzone drop');
      var dt = e.dataTransfer || {};
      var direct = Array.prototype.slice.call((dt.files||[]));
      var files = direct;
      if (!files.length && dt.items && dt.items.length){
        files = Array.prototype.slice.call(dt.items).map(function(it){ return it.getAsFile ? it.getAsFile() : null; }).filter(Boolean);
      }
      if (!files.length){ files = await gatherDroppedFiles(dt); }
      dlog('dropzone drop collected files='+files.length);
      if(files.length){ await handleFiles(files); }
      else { clearState(); showConsole(); println('0 images found'); addResetAction(); }
    }, false);

    // Manual picker
    dropzone.addEventListener('click', function(){
      dlog('open picker');
      var input=document.createElement('input');
      input.type='file'; input.multiple=true; input.webkitdirectory=true; input.setAttribute('directory','');
      input.accept='.jpg,.jpeg,.png,.webp,.gif,.bmp,.tif,.tiff,.heic,.heif,.zip';
      input.style.position='fixed'; input.style.left='-9999px';
      document.body.appendChild(input);
      input.addEventListener('change', async function(ev){ var files=Array.prototype.slice.call(ev.target.files||[]); dlog('picker files='+files.length); if(files.length) await handleFiles(files); input.remove(); }, {once:true});
      input.click();
    }, false);

  })();
</script>
</body>
</html>
